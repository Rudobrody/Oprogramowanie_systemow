/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "math.h"
#include "cmsis_os.h"
#include "time.h"
//#include "stdio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "ll_spi_ili9341.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* Definitions for LCD_Task */
osThreadId_t LCD_TaskHandle;
const osThreadAttr_t LCD_Task_attributes = {
  .name = "LCD_Task",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityLow,
};
/* Definitions for LED1_task */
osThreadId_t LED1_taskHandle;
const osThreadAttr_t LED1_task_attributes = {
  .name = "LED1_task",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for LED2_tack */
osThreadId_t LED2_tackHandle;
const osThreadAttr_t LED2_tack_attributes = {
  .name = "LED2_tack",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for BinarySem01 */
osSemaphoreId_t BinarySem01Handle;
const osSemaphoreAttr_t BinarySem01_attributes = {
  .name = "BinarySem01"
};
/* USER CODE BEGIN PV */
uint8_t DmaSpiCnt=1;

int etapProgramu = 0;
int ktoraCyfreWprowadza = 0;
unsigned char Key;
unsigned char oldKey;
unsigned char keyZamieniony;
int dziesiatkiX,dziesiatkiY,jednosciX,jednosciY, wspolrzedneX, wspolrzedneY;
int obecny_Y = 0;
int ktoraIteracja=0;
float odleglosc;
float zmienna_pomocnicza;
float wyjscieObiektu;
float zaklocenie;
unsigned char *napisX;
unsigned char *napisY;
unsigned char napisXX[] = {"X(1:100):  "};
unsigned char napisYY[] = {"Y(1:100):  "};
unsigned int nx=1;
unsigned int seed = 12345;

double XUchyb;
double YUchyb;

double XRegulator;
double YRegulator;
// Parametry regulatora PI

double kp = 0.5; // Wzmocnienie proporcjonalne
double ki = 0.2; // Wzmocnienie całkujące

double Xkp = 0.5; // Wzmocnienie proporcjonalne
double Xki = 0.2; // Wzmocnienie całkujące

double Ykp = 0.5; // Wzmocnienie proporcjonalne
double Yki = 0.2; // Wzmocnienie całkujące

// Parametry obiektu inercyjnego

double time_constant = 2.0; // Stała czasowa obiektu
double output = 0.0; // Aktualna wartość wyjścia obiektu

double Xtime_constant = 2.0; // Stała czasowa obiektu
double Xoutput = 0.0; // Aktualna wartość wyjścia obiektu

// Parametry obiektu inercyjnego
double Ytime_constant = 2.0; // Stała czasowa obiektu
double Youtput = 0.0; // Aktualna wartość wyjścia obiektu

// Zmienne pomocnicze dla regulatora PI

double error_integral = 0.0; // Całka błędów regulacji
double previous_error = 0.0; // Poprzedni błąd regulacji

double Xerror_integral = 0.0; // Całka błędów regulacji
double Xprevious_error = 0.0; // Poprzedni błąd regulacji

// Zmienne pomocnicze dla regulatora PI
double Yerror_integral = 0.0; // Całka błędów regulacji
double Yprevious_error = 0.0; // Poprzedni błąd regulacji



/////////////////////////////////////////////////////////////////////////////////////////////////////
/*
int x = 120, y = 160; // Skladowe x,y polozenia kwadratu
int x_old = 120, y_old = 160;
int dx = 1, dy = 1; // Skladowe wektora predkosci dx, dy

int odleglosc = 60;

#define Ts 0.05   // Czas próbkowania
#define Tp 10.0    // Czas procesu
int Wartosc_zadana; // Wartość zadana
#define y_0 0.0   // Warunki początkowe

double Kp = 0.8;   // Wzmocnienie
double Ki = 0.5;   // Czas zdwojenia
double Kd = 0.09;  // Czas wyprzedzenia

double Sterowanie = 0.0;   // Sygnał sterujący
double Uchyb = 0.0;   // Uchyb regulacji
double Suma_uchyb = 0.0;  // Suma uchybów
double Poprz_uchyb = 0.0; // Poprzedni uchyb

float Uchybq[230];
float Sterowanieq[230];
float Wyjscie_obiektuq[230];

unsigned char *ptr;
unsigned char *uchyba;
unsigned char *sterowaniea;
unsigned char *wyjsciea;
unsigned char napis[] = {"Odleglosc: "};
unsigned char napis1[] = {"Uchyb"};
unsigned char napis2[] = {"Sterowanie"};
unsigned char napis3[] = {"Regulator"};
int dl_n = 11;
int as = 5;
int ad = 10;
int af = 9;
unsigned int nx = 60;
unsigned int ny = 10;
unsigned int xas = 60;
unsigned int yas = 165;
unsigned int xad = 60;
unsigned int yad = 220;
unsigned int xaf = 60;
unsigned int yaf = 300;
unsigned int  key;
*/
/////////////////////////////////////////////////////////////////////

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_RNG_Init(void);
static void MX_SPI5_Init(void);
void StartLCDTask(void *argument);
void StartTaskLED1(void *argument);
void StartTaskLED2(void *argument);
/* USER CODE BEGIN PFP */
//void move_square_C(void);
double update_PI_controller(double setpoint, double feedback, double dt);
double Xupdate_PI_controller(double Xsetpoint, double Xfeedback, double Xdt, double* XRegulator);
double Yupdate_PI_controller(double Ysetpoint, double Yfeedback, double Ydt, double* YRegulator);
float pierwiastek(float liczba);
unsigned int generateRandomNumber(unsigned int *seed);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
/*
void move_square_C(){
//Aktualizacja po│ozenia na podstawie wektora predkosci
x+=dx;
y+=dy;
//Ograniczenie obszaru poruszania kwadratem w obrebie LCD
if (x <= 1 || x >= 240 - 34)
dx = -dx;
if (y <= 1 || y >= 320 - 34)
dy = -dy;
}
*/

double update_PI_controller(double setpoint, double feedback, double dt) {
    // Obliczanie błędu regulacji
    double error = setpoint - feedback;

    // Obliczanie składnika proporcjonalnego
    double proportional = kp * error;

    // Obliczanie składnika całkującego
    error_integral += error * dt;
    double integral = ki * error_integral;

    // Obliczanie sterowania
    double control_signal = proportional + integral;

    //Zaklocenie

    zaklocenie =0; //rand() % 7 - 3; // zakres zaklocenia od -3 do 3
    // Symulacja obiektu inercyjnego
    output += (control_signal - output+zaklocenie) * (dt / time_constant);

    // Aktualizacja poprzedniego błędu
    previous_error = error;

    return output;
}


double Xupdate_PI_controller(double Xsetpoint, double Xfeedback, double Xdt, double* XRegulator) {
    // Obliczanie błędu regulacji
    double Xerror = Xsetpoint - Xfeedback;

    // Obliczanie składnika proporcjonalnego
    double Xproportional = Xkp * Xerror;

    // Obliczanie składnika całkującego
    Xerror_integral += Xerror * Xdt;
    double Xintegral = Xki * Xerror_integral;

    // Obliczanie sterowania
    double Xcontrol_signal = Xproportional + Xintegral;
    *XRegulator = Xcontrol_signal;

    // Symulacja obiektu inercyjnego
    Xoutput += (Xcontrol_signal - Xoutput + zaklocenie ) * (Xdt / Xtime_constant);

    // Aktualizacja poprzedniego błędu
    Xprevious_error = Xerror;

    return Xoutput;
}

// Funkcja aktualizująca regulator PI
double Yupdate_PI_controller(double Ysetpoint, double Yfeedback, double Ydt, double* YRegulator)
{
    // Obliczanie błędu regulacji
    double Yerror = Ysetpoint - Yfeedback;

    // Obliczanie składnika proporcjonalnego
    double Yproportional = Ykp * Yerror;

    // Obliczanie składnika całkującego
    Yerror_integral += Yerror * Ydt;
    double Yintegral = Yki * Yerror_integral;

    // Obliczanie sterowania
    double Ycontrol_signal = Yproportional + Yintegral;
    *YRegulator=Ycontrol_signal;

    // Symulacja obiektu inercyjnego
    Youtput += (Ycontrol_signal - Youtput + zaklocenie) * (Ydt / Ytime_constant);

    // Aktualizacja poprzedniego błędu
    Yprevious_error = Yerror;

    return Youtput;
}

unsigned int generateRandomNumber(unsigned int *seed) {
    *seed = (1103515245 * (*seed) + 12345) % (1 << 31);
    return *seed % 101; // zakres od 0 do 100
}
float pierwiastek(float liczba)
{
    float pierwiastek_z_odl = liczba;
    float y = 1;
    float epsilon = 0.00001;

    while (pierwiastek_z_odl - y > epsilon)
    {
        pierwiastek_z_odl = (pierwiastek_z_odl + y) / 2;
        y = liczba / pierwiastek_z_odl;
    }
    return pierwiastek_z_odl;
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
	napisX = napisXX;
	napisY = napisYY;

/*
ptr = napis;
uchyba = napis1;
sterowaniea = napis2;
wyjsciea = napis3;
*/

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */

  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);
  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);

  NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  NVIC_SetPriority(PendSV_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));
  /* SysTick_IRQn interrupt configuration */
  NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_RNG_Init();
  MX_SPI5_Init();
  /* USER CODE BEGIN 2 */
  LL_DMA_DisableStream(DMA2, LL_DMA_STREAM_4);
  LL_DMA_ClearFlag_TC4(DMA2);
  LL_DMA_ClearFlag_TE4(DMA2);
  LL_SPI_EnableDMAReq_TX(SPI5);
  LL_DMA_EnableIT_TC(DMA2, LL_DMA_STREAM_4);
  LL_DMA_EnableIT_TE(DMA2, LL_DMA_STREAM_4);
  LL_SPI_Enable(SPI5);


  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* creation of BinarySem01 */
  BinarySem01Handle = osSemaphoreNew(1, 1, &BinarySem01_attributes);

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of LCD_Task */
  LCD_TaskHandle = osThreadNew(StartLCDTask, NULL, &LCD_Task_attributes);

  /* creation of LED1_task */
  LED1_taskHandle = osThreadNew(StartTaskLED1, NULL, &LED1_task_attributes);

  /* creation of LED2_tack */
  LED2_tackHandle = osThreadNew(StartTaskLED2, NULL, &LED2_tack_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {

    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_5);
  while(LL_FLASH_GetLatency()!= LL_FLASH_LATENCY_5)
  {
  }
  LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);
  LL_PWR_EnableOverDriveMode();
  LL_RCC_HSE_Enable();

   /* Wait till HSE is ready */
  while(LL_RCC_HSE_IsReady() != 1)
  {

  }
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, LL_RCC_PLLM_DIV_4, 180, LL_RCC_PLLP_DIV_2);
  LL_RCC_PLL_ConfigDomain_48M(LL_RCC_PLLSOURCE_HSE, LL_RCC_PLLM_DIV_4, 180, LL_RCC_PLLQ_DIV_8);
  LL_RCC_PLL_Enable();

   /* Wait till PLL is ready */
  while(LL_RCC_PLL_IsReady() != 1)
  {

  }
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_4);
  LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_2);
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);

   /* Wait till System clock is ready */
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
  {

  }
  LL_Init1msTick(180000000);
  LL_SetSystemCoreClock(180000000);
  LL_RCC_SetTIMPrescaler(LL_RCC_TIM_PRESCALER_TWICE);
}

/**
  * @brief RNG Initialization Function
  * @param None
  * @retval None
  */
static void MX_RNG_Init(void)
{

  /* USER CODE BEGIN RNG_Init 0 */

  /* USER CODE END RNG_Init 0 */

  /* Peripheral clock enable */
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_RNG);

  /* USER CODE BEGIN RNG_Init 1 */

  /* USER CODE END RNG_Init 1 */
  LL_RNG_Enable(RNG);
  /* USER CODE BEGIN RNG_Init 2 */

  /* USER CODE END RNG_Init 2 */

}

/**
  * @brief SPI5 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI5_Init(void)
{

  /* USER CODE BEGIN SPI5_Init 0 */

  /* USER CODE END SPI5_Init 0 */

  LL_SPI_InitTypeDef SPI_InitStruct = {0};

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* Peripheral clock enable */
  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SPI5);

  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOF);
  /**SPI5 GPIO Configuration
  PF7   ------> SPI5_SCK
  PF8   ------> SPI5_MISO
  PF9   ------> SPI5_MOSI
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_7|LL_GPIO_PIN_8|LL_GPIO_PIN_9;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_5;
  LL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  /* SPI5 DMA Init */

  /* SPI5_TX Init */
  LL_DMA_SetChannelSelection(DMA2, LL_DMA_STREAM_4, LL_DMA_CHANNEL_2);

  LL_DMA_SetDataTransferDirection(DMA2, LL_DMA_STREAM_4, LL_DMA_DIRECTION_MEMORY_TO_PERIPH);

  LL_DMA_SetStreamPriorityLevel(DMA2, LL_DMA_STREAM_4, LL_DMA_PRIORITY_LOW);

  LL_DMA_SetMode(DMA2, LL_DMA_STREAM_4, LL_DMA_MODE_CIRCULAR);

  LL_DMA_SetPeriphIncMode(DMA2, LL_DMA_STREAM_4, LL_DMA_PERIPH_NOINCREMENT);

  LL_DMA_SetMemoryIncMode(DMA2, LL_DMA_STREAM_4, LL_DMA_MEMORY_INCREMENT);

  LL_DMA_SetPeriphSize(DMA2, LL_DMA_STREAM_4, LL_DMA_PDATAALIGN_BYTE);

  LL_DMA_SetMemorySize(DMA2, LL_DMA_STREAM_4, LL_DMA_MDATAALIGN_BYTE);

  LL_DMA_DisableFifoMode(DMA2, LL_DMA_STREAM_4);

  /* USER CODE BEGIN SPI5_Init 1 */

  /* USER CODE END SPI5_Init 1 */
  /* SPI5 parameter configuration*/
  SPI_InitStruct.TransferDirection = LL_SPI_FULL_DUPLEX;
  SPI_InitStruct.Mode = LL_SPI_MODE_MASTER;
  SPI_InitStruct.DataWidth = LL_SPI_DATAWIDTH_8BIT;
  SPI_InitStruct.ClockPolarity = LL_SPI_POLARITY_LOW;
  SPI_InitStruct.ClockPhase = LL_SPI_PHASE_1EDGE;
  SPI_InitStruct.NSS = LL_SPI_NSS_SOFT;
  SPI_InitStruct.BaudRate = LL_SPI_BAUDRATEPRESCALER_DIV2;
  SPI_InitStruct.BitOrder = LL_SPI_MSB_FIRST;
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
  SPI_InitStruct.CRCPoly = 10;
  LL_SPI_Init(SPI5, &SPI_InitStruct);
  LL_SPI_SetStandard(SPI5, LL_SPI_PROTOCOL_MOTOROLA);
  /* USER CODE BEGIN SPI5_Init 2 */

  /* USER CODE END SPI5_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* Init with LL driver */
  /* DMA controller clock enable */
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA2);

  /* DMA interrupt init */
  /* DMA2_Stream4_IRQn interrupt configuration */
  NVIC_SetPriority(DMA2_Stream4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),5, 0));
  NVIC_EnableIRQ(DMA2_Stream4_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOF);
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOH);
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOG);
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);

  /**/
  LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_2);

  /**/
  LL_GPIO_ResetOutputPin(GPIOD, LL_GPIO_PIN_12|LL_GPIO_PIN_13);

  /**/
  LL_GPIO_ResetOutputPin(GPIOG, LL_GPIO_PIN_13|LL_GPIO_PIN_14);

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_2;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_0;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*PotencjometrPOT2
  GPIO_InitStruct.Pin = POT2_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
  LL_GPIO_Init(POT2_GPIO_Port, &GPIO_InitStruct);*/

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_12|LL_GPIO_PIN_13;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_13|LL_GPIO_PIN_14;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOG, &GPIO_InitStruct);

  /*PotencjometrPOT1
  GPIO_InitStruct.Pin = POT1_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
  LL_GPIO_Init(POT1_GPIO_Port, &GPIO_InitStruct);*/

}

/* USER CODE BEGIN 4 */
void DMA1_Stream4_TransferComplete(void)
{
  LL_DMA_ClearFlag_TC4(DMA2);
  DmaSpiCnt--;

  if(DmaSpiCnt == 0)
  {
    LL_DMA_DisableStream(DMA2, LL_DMA_STREAM_4);
    DmaSpiCnt=1;
    CS_DESELECT();
  }
}
/* USER CODE END 4 */

/* USER CODE BEGIN Header_StartLCDTask */
/**
  * @brief  Function implementing the LCD_Task thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartLCDTask */
void StartLCDTask(void *argument)
{
  /* USER CODE BEGIN 5 */
	TFTDisplay_ILI9341_Initialization(240, 320);
	  TFTDisplay_ILI9341_SetRotation(2);
	  TFTDisplay_ILI9341_FillScreen(TFT_COLOR_ILI9341_WHITE);
	  osDelay(1000);
// case 0 ------------------------------------------------------------------
	  for (int yy = 0; yy < 100; yy++) // kreska pionowa
	 	                    {

	 	                    	TFTDisplay_ILI9341_DrawPixel(30, yy, TFT_COLOR_ILI9341_RED);
	 	                    	TFTDisplay_ILI9341_DrawPixel(32, yy, TFT_COLOR_ILI9341_RED);
	 	                    	//SetPixel(ekran,30,yy);
	 	                        //SetPixel(ekran,32,yy);

	 	                    }

	 	                    for (int xx = 0; xx < 150; xx++) // kreska pozioma
	 	                    {
	 	                    	TFTDisplay_ILI9341_DrawPixel(xx, 0, TFT_COLOR_ILI9341_RED);
	 	                    	TFTDisplay_ILI9341_DrawPixel(xx, 2, TFT_COLOR_ILI9341_RED);
	 	                    	//SetPixel(ekran,xx,0);
	 	                        //SetPixel(ekran,xx,2);

	 	                    }

	 	                    for(int yy = 0; yy < 14; yy++) // balast
	 	                    {
	 	                        for(int xx = 0;xx < 8; xx++)
	 	                        {
	 	                        	TFTDisplay_ILI9341_DrawPixel(xx, yy, TFT_COLOR_ILI9341_RED);
	 	                        	//SetPixel(ekran,xx,yy);
	 	                        }
	 	                    }

	 	                    for(int yy = 8; yy < 24; yy++) // kabina czesc pionowa
	 	                    {
	 	                    	TFTDisplay_ILI9341_DrawPixel(44, yy, TFT_COLOR_ILI9341_RED);
	 	                    	//SetPixel(ekran,44,yy);
	 	                    }

	 	                    for(int xx = 32; xx < 44; xx++) // kabina czesc pozioma
	 	                    {
	 	                    	TFTDisplay_ILI9341_DrawPixel(xx, 8, TFT_COLOR_ILI9341_RED);
	 	                    	TFTDisplay_ILI9341_DrawPixel(xx, 24, TFT_COLOR_ILI9341_RED);
	 	                    	//SetPixel(ekran,xx,8);
	 	                        //SetPixel(ekran,xx,24);
	 	                    }

// case 0 END -------------------------------------------------------------------------------
// case 1 ------------------------------------------------------------------

	 	                   	                    for(int xx = 160; xx < 238; xx++) // oś x dolnego wykresu
	 	                   	                    {
	 	                   	                    	TFTDisplay_ILI9341_DrawPixel(xx, 123, TFT_COLOR_ILI9341_RED);
	 	                   	                    	//SetPixel(ekran,xx,123);
	 	                   	                    }

	 	                   	                    for(int yy = 73; yy < 123; yy++) // oś y dolnego wykresu
	 	                   	                    {
	 	                   	                    	TFTDisplay_ILI9341_DrawPixel(160, yy, TFT_COLOR_ILI9341_RED);
	 	                   	                    	//SetPixel(ekran,160,yy);
	 	                   	                    }

	 	                   	                    for(int xx = 160; xx < 238; xx++) // oś x górnego wykresu
	 	                   	                    {
	 	                   	                    	TFTDisplay_ILI9341_DrawPixel(xx, 51, TFT_COLOR_ILI9341_RED);
	 	                   	                    	//SetPixel(ekran,xx,51);
	 	                   	                    }

	 	                   	                    for(int yy = 1; yy < 51; yy++) // oś y górnego wykresu
	 	                   	                    {
	 	                   	                    	TFTDisplay_ILI9341_DrawPixel(160, yy, TFT_COLOR_ILI9341_RED);
	 	                   	                    	//SetPixel(ekran,160,yy);
	 	                   	                    }
// case 1 END -------------------------------------------------------------------------------

	 	                   // case 2 ------------------------------------------------------------------

	 	                   	                    //unsigned int seedX = (unsigned int)time(NULL);

	 	                  	                	// unsigned int seedY = (unsigned int)time(NULL);

	 	                  	                	//wspolrzedneX=(int)generateRandomNumber(&seedX);
												//wspolrzedneY=(int)generateRandomNumber(&seedY);
	 	                   	                wspolrzedneX=50;
											wspolrzedneY=90;
	 	                    // case 2 END -------------------------------------------------------------------------------
	 	                   // case 3 ------------------------------------------------------------------
	 	                  	                	for (int yy = wspolrzedneY - 3; yy < (wspolrzedneY + 3); yy++)
	 	                  	                		                    {
	 	                  	                		                        ktoraIteracja++;
	 	                  	                		                        for (;;)
	 	                  	                		                        {
	 	                  	                		                            int xx = 50 + (wspolrzedneX - 3 + ktoraIteracja); // 50 to offset rysunku
	 	                  	                		                            TFTDisplay_ILI9341_DrawPixel(xx, yy, TFT_COLOR_ILI9341_RED);
	 	                  	                		                            TFTDisplay_ILI9341_DrawPixel(xx, (wspolrzedneY + 3 - ktoraIteracja), TFT_COLOR_ILI9341_RED);
	 	                  	                		                            //SetPixel(ekran,xx,yy);
	 	                  	                		                            //SetPixel(ekran,xx,(wspolrzedneY + 3 - ktoraIteracja));
	 	                  	                		                            break;
	 	                  	                		                        }

	 	                  	                		                    }

	 	                  	                		                    for (int yy = 0; yy <= wspolrzedneY-6 ; yy++ ) //  było 91, 97 jako srodek  bo bo klocek przenoszony ma wyokosc 4 wiec zeby lina byla przyczepiona do gory
	 	                  	                		                                        {
	 	                  	                		                    					TFTDisplay_ILI9341_DrawPixel(wspolrzedneX+50, yy, TFT_COLOR_ILI9341_RED);
	 	                  	                		                    					//SetPixel(ekran,wspolrzedneX+50,yy); //offset z rysunku
	 	                  	                		                                        }

	 	                  	                		                                        for(int yy = wspolrzedneY-6; yy < wspolrzedneY+6; yy++) // bylo od 91 do 103, ładunek czesc pionowa
	 	                  	                		                                        {
	 	                  	                		                                        	TFTDisplay_ILI9341_DrawPixel(wspolrzedneX-8+50, yy, TFT_COLOR_ILI9341_RED);
	 	                  	                		                                        	TFTDisplay_ILI9341_DrawPixel(wspolrzedneX+8+50, yy, TFT_COLOR_ILI9341_RED);
	 	                  	                		                                        	//SetPixel(ekran,wspolrzedneX-8+50,yy); // bylo x 142
	 	                  	                		                                            // SetPixel(ekran,wspolrzedneX+8+50,yy); // bylo x 158
	 	                  	                		                                        }

	 	                  	                		                                        for(int xx = wspolrzedneX-8; xx < wspolrzedneX+8; xx++) // ładunek czesc pozioma
	 	                  	                		                                        {
	 	                  	                		                                        	TFTDisplay_ILI9341_DrawPixel(xx+50, wspolrzedneY-6, TFT_COLOR_ILI9341_RED);
	 	                  	                		                                        	TFTDisplay_ILI9341_DrawPixel(xx+50, wspolrzedneY+6, TFT_COLOR_ILI9341_RED);
	 	                  	                		                                        	//SetPixel(ekran,xx+50,wspolrzedneY-6); // bylo y 91
	 	                  	                		                                            //SetPixel(ekran,xx+50,wspolrzedneY+6); // bylo y 103
	 	                  	                		                                        }
	 	                  	                	 // case 3 END -------------------------------------------------------------------------------
	 	                   // case 4 ------------------------------------------------------------------
	 	                  	                		                                     zmienna_pomocnicza = (wspolrzedneX*wspolrzedneX)+(wspolrzedneY*wspolrzedneY);
	 	                  	                		                                     	                    odleglosc = pierwiastek(zmienna_pomocnicza);
	 	                  	                		                                     	                    // odleglosc = sqrt((wspolrzedneX*wspolrzedneX)+(wspolrzedneY*wspolrzedneY)); // odleglosc jest ok podawana
	 	                  	                		                                     	                  //  printf("Odległosc: %f \n", odleglosc);
	 	                  	                		                                        // case 4 END -------------------------------------------------------------------------------
	 	                   // case 5 ------------------------------------------------------------------
	 	                  	                		                                     	                for(int xx = 160; xx < 238; xx++) // oś x dolnego wykresu
	 	                  	                		                                     	                	                    {
	 	                  	                		                                     	                	                    	TFTDisplay_ILI9341_DrawPixel(xx, (123-((int)odleglosc/2)), TFT_COLOR_ILI9341_RED);
	 	                  	                		                                     	                	                    	//SetPixel(ekran,xx,(123-((int)odleglosc/2))); // odleglosc dzielę przez 2 bo uzytkownik wprowadza wartosci do 100 a wykres jest wyskalowany na 50
	 	                  	                		                                     	                	                    }
	 	                  	                		                                     	                    // case 5 END -------------------------------------------------------------------------------
	 	                   // case 6 ------------------------------------------------------------------
	 	                  	                		                                     	            double setpoint = odleglosc; // Wartość zadanowa
	 	                  	                		                                     	           	                    double feedback = 0.0; // Wartość sprzężenia zwrotnego
	 	                  	                		                                     	           	                    double dt = 0.06; // Krok czasowy
	 	                  	                		                                     	           	                    float xx = 160;

	 	                  	                		                                     	           	                    double Xsetpoint = wspolrzedneX;
	 	                  	                		                                     	           	                                        double Ysetpoint = wspolrzedneY;
	 	                  	                		                                     	           	                                        double Xfeedback = 0.0;
	 	                  	                		                                     	           	                                        double Yfeedback = 0.0;
	 	                  	                		                                     	           	                                        double Xdt = 0.06;
	 	                  	                		                                     	           	                                        double Ydt = 0.06;

	 	                  	                		                                     	           	                        // Symulacja regulacji przez pewien czas

	 	                  	                		                                     	           	                    for (int i = 0; i < 1000; i++)
	 	                  	                		                                     	           	                    {
	 	                  	                		                                     	           	                        double control_output = update_PI_controller(setpoint, feedback, dt);
	 	                  	                		                                     	           	                        double X_control_output = Xupdate_PI_controller(Xsetpoint, Xfeedback, Xdt, &XRegulator);
	 	                  	                		                                     	           	                        double Y_control_output = Yupdate_PI_controller(Ysetpoint, Yfeedback, Ydt, &YRegulator);

	 	                  	                		                                     	           	                        feedback = control_output; // Aktualizacja wartości sprzężenia zwrotnego
	 	                  	                		                                     	           	                        Xfeedback = X_control_output;
	 	                  	                		                                     	           	                        Yfeedback = Y_control_output;

	 	                  	                		                                     	           	                        XUchyb = Xsetpoint - Xfeedback;
	 	                  	                		                                     	           	                        YUchyb = Ysetpoint - Yfeedback;
	 	                  	                		                                     	           	                        //printf("Czas: %.1f, Wyjście: %.2f\n", i * dt, control_output);

	 	                  	                		                                     	           	                      //  printf("Czas: %.1f, Wyjście_x: %.2f, Regulator_x: %.2f, Uchyb_x: %.2f \n", i * Xdt, X_control_output, XRegulator, XUchyb);
	 	                  	                		                                     	           	                      //  printf("Czas: %.1f, Wyjście_y: %.2f, Regulator_y: %.2f, Uchyb_y: %.2f \n", i * Ydt, Y_control_output, YRegulator, YUchyb);

	 	                  	                		                                     	           	                   //     printf("Czas: %.1f, Wyjście_x: %.2f, Uchyb_x: %.2f, Regulator_x: %.2f \n", i * Xdt, X_control_output, XUchyb, XRegulator);
	 	                  	                		                                     	           	                   //     printf("Czas: %.1f, Wyjście_y: %.2f, Uchyb_y: %.2f, Regulator_y: %.2f \n", i * Ydt, Y_control_output, YUchyb, YRegulator);

	 	                  	                		                                     	           	                        xx += 0.078;
	 	                  	                		                                     	           	                    	TFTDisplay_ILI9341_DrawPixel((int)xx, (123-(int)control_output/2), TFT_COLOR_ILI9341_RED);
	 	                  	                		                                     	           	                    	TFTDisplay_ILI9341_DrawPixel((int)xx, (51-(int)(setpoint-feedback)/2), TFT_COLOR_ILI9341_RED);
	 	                  	                		                                     	           	                    	osDelay(200);
	 	                  	                		                                     	           	                       // SetPixel(ekran,(int)xx, (123-(int)control_output/2)); // wartosc zadana

	 	                  	                		                                     	           	                       // SetPixel(ekran,(int)xx, (51-(int)(setpoint-feedback)/2)); // uchyb




	 	                  	                		                                     	           	                       // EnableRefresh = 1;
	 	                  	                		                                     	           	                                 //   LCD.Synchronize();
	 	                  	                		                                     	           	                                //    EnableRefresh = 0;

	 	                  	                		                                     	           	                    }
	 	                  	                		                                     	                // case 6 END -------------------------------------------------------------------------------






	for (int i=0; i < 20; i++)
	{
	  TFTDisplay_ILI9341_DrawChar (nx, 14, *napisX);
	  TFTDisplay_ILI9341_DrawChar (nx, 15, *napisY);
	  nx= nx +10;
	  napisX++;
	  napisY++;
	}


//*/
/*
  TFTDisplay_ILI9341_Initialization(240, 320);
  TFTDisplay_ILI9341_SetRotation(2);
  TFTDisplay_ILI9341_FillScreen(TFT_COLOR_ILI9341_WHITE);
  osDelay(1000);

  //KORPUS
  TFTDisplay_ILI9341_DrawLine(0, 160, 240, 160, TFT_COLOR_ILI9341_BLACK);
  TFTDisplay_ILI9341_FillRect(0, 160, 25, 145, TFT_COLOR_ILI9341_NAVY);

  //LUFA
  TFTDisplay_ILI9341_DrawLine(3, 145, 25, 123, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(3, 145, 25, 124, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(4, 145, 26, 124, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(4, 145, 26, 125, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(5, 145, 27, 125, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(5, 145, 27, 126, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(6, 145, 28, 126, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(6, 145, 28, 127, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(7, 145, 29, 127, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(7, 145, 29, 128, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(8, 145, 30, 128, TFT_COLOR_ILI9341_NAVY);
  TFTDisplay_ILI9341_DrawLine(8, 145, 30, 129, TFT_COLOR_ILI9341_NAVY);

  //OSIE
  TFTDisplay_ILI9341_DrawLine(28, 126, 240, 126, TFT_COLOR_ILI9341_GREEN);
  TFTDisplay_ILI9341_DrawLine(28, 0, 28, 126, TFT_COLOR_ILI9341_BLUE);

  //NAPIS ODLEGLOSC
  for (int i=0; i < dl_n; i++){
  TFTDisplay_ILI9341_DrawChar (nx, ny, *ptr);
  nx= nx +10;
  ptr++;
  }

  for (int i=0; i < as; i++){
  TFTDisplay_ILI9341_DrawChar (xas, yas, *uchyba);
  xas= xas +10;
  uchyba++;
  }

  for (int i=0; i < ad; i++){
  TFTDisplay_ILI9341_DrawChar (xad, yad, *sterowaniea);
  xad= xad +10;
  sterowaniea++;
  }

  for (int i=0; i < af; i++){
  TFTDisplay_ILI9341_DrawChar (xaf, yaf, *wyjsciea);
  xaf= xaf +10;
  wyjsciea++;
  }
  //ZADANY PUNKT
  Wartosc_zadana = (odleglosc-0)*(239-28)/(99-0)+28;
  for (int l = 0; l < 12; l++){
  TFTDisplay_ILI9341_DrawPixel(Wartosc_zadana-0, 126 + l, TFT_COLOR_ILI9341_RED);
 TFTDisplay_ILI9341_DrawPixel(Wartosc_zadana-1, 126 + l, TFT_COLOR_ILI9341_RED);
  }

  //RYSOWANIE PARABOLI
 double Wyjscie_obiektu = y_0;
 double t = 0.0;
 double Poprz_wyjscie_obiektu = Wyjscie_obiektu;

  while (t < Tp) {
 for (int j=0;j<230;j++){
Uchyb = Wartosc_zadana - Wyjscie_obiektu;
        Suma_uchyb += Uchyb * Ts;
        Sterowanie = Kp * Uchyb + Ki * Suma_uchyb + Kd * (Uchyb - Poprz_uchyb) / Ts;

        Poprz_wyjscie_obiektu = Wyjscie_obiektu;
        int wykres;
        Wyjscie_obiektu = exp(-Ts / Ki) * Wyjscie_obiektu + (1 - exp(-Ts / Ki)) / Ki * Sterowanie;
        wykres = Wyjscie_obiektu;
        Poprz_uchyb = Uchyb;
        t += Ts;
        Uchybq[j] = Uchyb;
        Sterowanieq[j] = Sterowanie;
        Wyjscie_obiektuq[j] = Wyjscie_obiektu;
        TFTDisplay_ILI9341_FillRect(29, 30, 239, 125, TFT_COLOR_ILI9341_WHITE);
  for (int g = 28; g < 239; g++){
  TFTDisplay_ILI9341_FillRect(29, 25, 240, 125, TFT_COLOR_ILI9341_RED);
  int h=0.005*(g-28)*(g-wykres)+126;
    if (h<=126){
  TFTDisplay_ILI9341_DrawPixel(g, h, TFT_COLOR_ILI9341_BLACK);
    }
  }
}
  TFTDisplay_ILI9341_DrawLine(4, 165, 4, 316, TFT_COLOR_ILI9341_RED);
  TFTDisplay_ILI9341_DrawLine(4, 221, 236, 221, TFT_COLOR_ILI9341_RED);
  TFTDisplay_ILI9341_DrawLine(4, 316, 236, 316, TFT_COLOR_ILI9341_RED);


    for (int k=0;k<230;k++){
   int z = -Uchybq[k]/2;
    TFTDisplay_ILI9341_DrawPixel((4+k),(z+220) ,TFT_COLOR_ILI9341_BLACK);
    }
    for (int k=0;k<230;k++){
   int z = Sterowanieq[k];
    TFTDisplay_ILI9341_DrawPixel((4+k),(z+195) ,TFT_COLOR_ILI9341_GREENYELLOW);
    }
    for (int k=0;k<230;k++){
   int z = -Wyjscie_obiektuq[k]/2;
    TFTDisplay_ILI9341_DrawPixel((4+k),(z+350) ,TFT_COLOR_ILI9341_BLUE);
    }
 }

while(!(GPIOA -> IDR & 0x0001)) //sprawdzanie klawisza pod PA0
{
//odleglosc = rand();
osDelay(2);//aby nie blokować innych tasków
}
*/

  /* Infinite loop */
	/*
  for(;;)
  {


TFTDisplay_ILI9341_FillRect(x, y, x+30, y+30, TFT_COLOR_ILI9341_RED);
osDelay(4);
move_square_C();
TFTDisplay_ILI9341_FillRect(x_old, y_old, x_old+30, y_old+30, TFT_COLOR_ILI9341_BLUE);
x_old = x;
y_old = y;

  }
  */

  /* USER CODE END 5 */
}

/* USER CODE BEGIN Header_StartTaskLED1 */
/**
* @brief Function implementing the LED1_task thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskLED1 */
void StartTaskLED1(void *argument)
{
  /* USER CODE BEGIN StartTaskLED1 */
  /* Infinite loop */
  for(;;)
  {

  osSemaphoreAcquire(BinarySem01Handle, osWaitForever);  //synchronizacja tasków - zwolnienie w TaskLED2

  LL_GPIO_TogglePin(GPIOG, LL_GPIO_PIN_13);


  osDelay(100);
  }
  /* USER CODE END StartTaskLED1 */
}

/* USER CODE BEGIN Header_StartTaskLED2 */
/**
* @brief Function implementing the LED2_tack thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskLED2 */
void StartTaskLED2(void *argument)
{
  /* USER CODE BEGIN StartTaskLED2 */
  /* Infinite loop */
  for(;;)
  {


  LL_GPIO_TogglePin(GPIOG, LL_GPIO_PIN_14);

  osDelay(1000);
  osSemaphoreRelease(BinarySem01Handle);//zwolnienie semafora i odblokowanie TaskLED1

  ;
  }
  /* USER CODE END StartTaskLED2 */
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
